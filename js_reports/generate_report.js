const pptxgen = require('pptxgenjs');
const puppeteer = require('puppeteer');
const docx = require('docx');
const fs = require('fs');
const path = require('path');
const { marked } = require('marked');

async function generateReport() {
    const args = process.argv.slice(2);
    if (args.length < 3) {
        console.error("Usage: node generate_report.js <format> <outputFile> <contentFile>");
        process.exit(1);
    }

    const format = args[0];
    const outputFile = args[1];
    const contentFile = args[2];

    let content = "";
    try {
        content = fs.readFileSync(contentFile, 'utf8');
    } catch (e) {
        console.error(`Error reading content file: ${e.message}`);
        process.exit(1);
    }

    try {
        if (format === 'ppt' || format === 'pptx') {
            await generatePPT(content, outputFile);
        } else if (format === 'pdf') {
            await generatePDF(content, outputFile);
        } else if (format === 'docx') {
            await generateDOCX(content, outputFile);
        } else {
            console.error("Unknown format");
            process.exit(1);
        }
    } catch (err) {
        console.error(`Generation failed: ${err}`);
        process.exit(1);
    }
}

// --- PPT GENERATION ---
async function generatePPT(content, outputFile) {
    let pres = new pptxgen();

    // Layout
    pres.layout = 'LAYOUT_16x9';

    // Title Slide
    let slide = pres.addSlide();
    slide.addText("Research Report", { x: 1, y: 1.5, w: '80%', fontSize: 44, bold: true, color: '2D3436', align: 'center' });
    slide.addText("Generated by DeepResearcher", { x: 1, y: 3, w: '80%', fontSize: 24, color: '636E72', align: 'center' });

    // Parse Content into Sections based on Headers
    // Simple split by Headers (#, ##, ###)
    const lines = content.split('\n');
    let currentTitle = "Overview";
    let currentBody = [];

    const flushSlide = () => {
        if (currentBody.length === 0) return;

        // rudimentary pagination: roughly 12 lines per slide
        const maxLines = 10;
        let slideBody = [];

        for (let i = 0; i < currentBody.length; i++) {
            slideBody.push(currentBody[i]);

            if (slideBody.length >= maxLines || i === currentBody.length - 1) {
                let s = pres.addSlide();

                // Add Title
                s.addText(currentTitle, { x: 0.5, y: 0.5, w: '90%', fontSize: 24, bold: true, color: '2D3436', bb: { line: { color: 'DFE6E9', width: 2 } } }); // bold border bottom

                // Add Body
                let yPos = 1.5;
                slideBody.forEach(item => {
                    // Check if bullet
                    if (item.type === 'bullet') {
                        s.addText(item.text, { x: 0.5, y: yPos, w: '90%', fontSize: 16, color: '2D3436', bullet: true, paraSpaceBefore: 10 });
                        yPos += 0.4;
                    } else if (item.type === 'para') {
                        if (item.text.trim().length > 0) {
                            s.addText(item.text, { x: 0.5, y: yPos, w: '90%', fontSize: 16, color: '2D3436', paraSpaceBefore: 10 });
                            // Estimate height roughly
                            let lines = Math.ceil(item.text.length / 100);
                            yPos += (0.4 * lines);
                        }
                    }
                });

                slideBody = []; // reset for next page of same section
                // Add (Cont.) to title for next slides
                if (!currentTitle.includes("(Cont.)")) currentTitle += " (Cont.)";
            }
        }
    };

    for (let line of lines) {
        line = line.trim();
        if (line.startsWith('#')) {
            // New Section
            flushSlide(); // Write previous section
            currentTitle = line.replace(/#/g, '').trim();
            currentBody = [];
        } else if (line.match(/^[\*\-]\s/)) {
            // Bullet item
            let text = line.replace(/^[\*\-]\s/, '').trim();
            // Remove bold/markdown chars
            text = text.replace(/\*\*/g, '').replace(/__/g, '');
            currentBody.push({ type: 'bullet', text: text });
        } else {
            // Paragraph
            if (line.length > 0) {
                let text = line.replace(/\*\*/g, '').replace(/__/g, '');
                currentBody.push({ type: 'para', text: text });
            }
        }
    }
    flushSlide(); // Flush last section

    await pres.writeFile({ fileName: outputFile });
    fixPPTFileExtension(outputFile);
}

function fixPPTFileExtension(outputFile) {
    if (!fs.existsSync(outputFile)) {
        if (fs.existsSync(outputFile + ".pptx")) {
            fs.renameSync(outputFile + ".pptx", outputFile);
        }
    }
    console.log(`PPT generated at ${outputFile}`);
}

// --- PDF GENERATION ---
async function generatePDF(content, outputFile) {
    const browser = await puppeteer.launch({ headless: "new" });
    const page = await browser.newPage();

    // Convert Markdown to HTML
    const htmlBody = marked.parse(content);

    const htmlContent = `
    <!DOCTYPE html>
    <html>
    <head>
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
        <style>
            body { font-family: 'Inter', sans-serif; color: #333; margin: 0; padding: 40px; line-height: 1.6; }
            h1, h2, h3 { color: #2D3436; margin-top: 1.5em; margin-bottom: 0.5em; }
            h1 { font-size: 28px; border-bottom: 2px solid #EEE; padding-bottom: 10px; }
            h2 { font-size: 22px; }
            p { margin-bottom: 1em; text-align: justify; }
            li { margin-bottom: 0.5em; }
            code { background: #F4F4F4; padding: 2px 5px; border-radius: 4px; font-family: monospace; }
            blockquote { border-left: 4px solid #DFE6E9; padding-left: 15px; color: #636E72; font-style: italic; }
            .header { text-align: center; margin-bottom: 40px; }
            .footer { margin-top: 50px; font-size: 10px; color: #999; text-align: center; border-top: 1px solid #EEE; padding-top: 20px; }
        </style>
    </head>
    <body>
        <div class="header">
            <h1>Research Report</h1>
        </div>
        <div class="content">
            ${htmlBody}
        </div>
        <div class="footer">
            Generated by DeepResearcher Agent
        </div>
    </body>
    </html>
    `;

    await page.setContent(htmlContent);
    await page.pdf({
        path: outputFile,
        format: 'A4',
        printBackground: true,
        margin: { top: '20mm', bottom: '20mm', left: '20mm', right: '20mm' }
    });

    await browser.close();
    console.log(`PDF generated at ${outputFile}`);
}

// --- DOCX GENERATION ---
async function generateDOCX(content, outputFile) {
    const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = docx;

    const lines = content.split('\n');
    const children = [];

    // Add Title
    children.push(new Paragraph({
        text: "Research Report",
        heading: HeadingLevel.TITLE,
        alignment: AlignmentType.CENTER,
        spacing: { after: 400 }
    }));

    for (let line of lines) {
        line = line.trim();
        if (line.length === 0) continue;

        if (line.startsWith('# ')) {
            // Heading 1
            children.push(new Paragraph({
                text: line.replace('# ', '').replace(/\*\*/g, ''),
                heading: HeadingLevel.HEADING_1,
                spacing: { before: 200, after: 100 }
            }));
        } else if (line.startsWith('## ')) {
            // Heading 2
            children.push(new Paragraph({
                text: line.replace('## ', '').replace(/\*\*/g, ''),
                heading: HeadingLevel.HEADING_2,
                spacing: { before: 200, after: 100 }
            }));
        } else if (line.startsWith('### ')) {
            // Heading 3
            children.push(new Paragraph({
                text: line.replace('### ', '').replace(/\*\*/g, ''),
                heading: HeadingLevel.HEADING_3,
                spacing: { before: 100, after: 50 }
            }));
        } else if (line.match(/^[\*\-]\s/)) {
            // Bullet List
            children.push(new Paragraph({
                text: line.replace(/^[\*\-]\s/, '').replace(/\*\*/g, ''),
                bullet: { level: 0 }
            }));
        } else {
            // Normal Paragraph
            children.push(new Paragraph({
                text: line.replace(/\*\*/g, ''),
                spacing: { after: 120 }
            }));
        }
    }

    const doc = new Document({
        sections: [{
            properties: {},
            children: children,
        }],
    });

    const buffer = await Packer.toBuffer(doc);
    fs.writeFileSync(outputFile, buffer);
    console.log(`DOCX generated at ${outputFile}`);
}

generateReport();
